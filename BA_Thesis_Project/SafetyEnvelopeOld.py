import numpy as np

class SafetyEnvelopeOld:

    # TODO: check, add func to get time_step, max_advance robot, max_rotation from congif file in the main func or somewhere else and update this constructor,
    #  incase change the value in congif file but forhet to change in this constructor -> be careful now. Also consider the main_function_action will be not in the constructor
    #  but maybe be given as parameter in function like SE.check(main_function_action( which will call other func that need to use this main_func and add this action as argument
    #
    def __init__(self, env,human_assumed_speed=2, time_step=1, max_advance_robot=0.1, max_rotation= 3.141592653589793, a_max=1.5  ):
        self.env= env
        self.a_max = a_max

        self.max_advance_robot=max_advance_robot
        self.max_rotation=max_rotation
        self.time_step=time_step
        self.human_assumed_speed=human_assumed_speed


    # next_action calculate what is the next action to execute. it checks if the generated action of the main_func is safe
    # if yes, execute this action. if no, override with stop action -> stop robot immediately.
    def next_action(self, main_function_action, observation, epsilon):
        main_function_action_safe, alertness_value= self.is_main_function_action_safe(main_function_action, observation, epsilon)
        if main_function_action_safe:
            return main_function_action, alertness_value
        else:  #in case the main_function_action is not safe -> override with stop action
            stop_action= np.array([0, 0, 0],dtype=np.float32 )
            return stop_action, alertness_value



    # this func will check the action generated by the main chanel and call the below function to do calculation, check if this func will be safe to execute
    # return True False
    def is_main_function_action_safe(self, main_function_action, observation, epsilon):
        min_braking_distance= self.predict_min_robot_braking_distance(main_function_action)
        estimated_d_min= self.estimate_d_min(main_function_action, observation)
        alertness_value= self.compute_continuous_safety_signal(min_braking_distance, estimated_d_min, 2*estimated_d_min)
        if min_braking_distance+epsilon>= estimated_d_min:
            return False,alertness_value
        return True, alertness_value

    # calculate the alertness value
    def compute_continuous_safety_signal(self, min_braking_distance, estimated_d_min, d_warn):
        if estimated_d_min<= min_braking_distance:
            alertness_value=1
        elif d_warn>= estimated_d_min > min_braking_distance:
            alertness_value= (d_warn- estimated_d_min)/(d_warn-min_braking_distance)
        else:
            alertness_value = 0
        return alertness_value

    # predict d_min
    def estimate_d_min(self, main_function_action,observation):
        d_min = float('inf')
        # extract robot radius from the observation
        robot_radius=observation["robot"][8]

        # predict new distance from robot to each obstacle and find the minimum
        for key in ["humans", "plants", "laptops", "tables", "walls"]:
            obstacle_obs= observation[key]
            assert(len(obstacle_obs%14==0))
            number_of_obstacles= int(len(obstacle_obs)/14)
            for i in range(0, number_of_obstacles):
                obstacle_relative_position_x= obstacle_obs[6+i*14]
                obstacle_relative_position_y = obstacle_obs[7 + i * 14]
                obstacle_radius=  obstacle_obs[10+ i * 14]
                predicted_new_distance=self.estimate_new_distance(main_function_action, obstacle_relative_position_x,obstacle_relative_position_y, key,robot_radius, obstacle_radius )
                if d_min >predicted_new_distance:
                    d_min=predicted_new_distance
        return  d_min


    # estimate the new distance between robot and 1 obstacle within one time frame if execute the main_function_action
    def estimate_new_distance(self,main_function_action, obstacle_relative_position_x, obstacle_relative_position_y, obstacle_key, robot_radius, obstacle_radius):
        # calculate current distance between robot and obstacle
        # note that the position.x and position.y coordinates given in observation is RELATIVE to robot
        current_distance= np.sqrt(obstacle_relative_position_x**2 + obstacle_relative_position_y**2)

        # calculate distance delta_p robot can move within 1 time step if the action from main function is executed
        robot_delta_x, robot_delta_y= self.predict_delta_distance_robot_within_1step(main_function_action)
        robot_delta_distance=np.sqrt(robot_delta_x**2 + robot_delta_y**2)

        # calculate the distance human can move within 1 time step
        if obstacle_key== "humans":
            obstacle_delta_distance= self.human_assumed_speed*self.time_step
        else:
            obstacle_delta_distance=0 # other obstacle like walls, plants... are static
        #calculate predicted distance
        # estimate this distance using the worst case scenario, meaning that the real distance will be >= this predicted new distance
        predict_new_distance= current_distance-robot_delta_distance-obstacle_delta_distance -obstacle_radius-robot_radius
        return predict_new_distance


    # estimate the distance robot can move within one time step
    def predict_delta_distance_robot_within_1step(self,main_function_action):
        robot = self.env.get_wrapper_attr("robot")
        # get robot current heading
        robot_orientation = robot.orientation

        # get vel_x, vel_y, vel_a in [-1,1] from the action and scaled it to true vel_x, vel_y, vel_a
        main_func_vel_x = main_function_action[0] * self.max_advance_robot
        main_func_vel_y = main_function_action[1] * self.max_advance_robot
        main_func_vel_a = main_function_action[2] * self.max_rotation

        # predict new robot orientation after executing the main_function action, then wrap it to [-pi, pi]
        robot_orientation += main_func_vel_a * self.time_step
        robot_orientation = self.wrap(robot_orientation)

        # predict linear component
        delta_x= main_func_vel_x * np.cos(robot_orientation) * self.time_step
        delta_y = main_func_vel_x * np.sin(robot_orientation) * self.time_step

        # predict perpendicular component
        delta_x += main_func_vel_y * np.cos(np.pi / 2 + robot_orientation) * self.time_step
        delta_y += main_func_vel_y * np.sin(np.pi / 2 + robot_orientation) * self.time_step

        return delta_x, delta_y

    # predict new position of robot if taking the action generated by the main chanel
    def predict_new_robot_position(self,main_function_action):
        robot = self.env.get_wrapper_attr("robot")  # returns env.robot if it exists
        # get robot current position and heading
        robot_x, robot_y = robot.x, robot.y
        delta_x, delta_y= self.predict_delta_distance_robot_within_1step(main_function_action)
        robot_x+= delta_x
        robot_y+= delta_y
        return robot_x, robot_y

    # predict the min braking distance robot travel until fully stop, a_max,
    # based on predicted speed if executing the main chanel func 's generated action
    def predict_min_robot_braking_distance(self, main_function_action):
        robot_predicted_speed= self.predict_robot_speed( main_function_action)
        min_predicted_braking_distance = (robot_predicted_speed ** 2) / (2 * self.a_max)
        return min_predicted_braking_distance


    # predict robot speed if executing the action generated from the main func/main chanel
    def predict_robot_speed(self, main_function_action):
        # the action space outputs values between -1 and 1 for each action dimension->need to scale those normalized
        # value to the true robot physical limits
        robot_predicted_v_x, robot_predicted_v_y= main_function_action[0]*self.max_advance_robot, main_function_action[1]*self.max_advance_robot
        robot_predicted_speed= np.sqrt(robot_predicted_v_x**2+ robot_predicted_v_y**2)
        return robot_predicted_speed

    # not used .calculate the min braking distance robot travel until fully stop, with a_max, based on CURRENT speed
    def calculate_min_robot_braking_distance(self):
        # get robot current speed
        robot_speed = self.get_robot_current_speed()
        min_braking_distance = (robot_speed ** 2) / (2 * self.a_max)
        return min_braking_distance

    # not used now.return current speed of robot before env.step()
    def get_robot_current_speed(self):
        robot = self.env.get_wrapper_attr("robot")  # returns env.robot if it exists
        robot_v_x, robot_v_y= robot.vel_x, robot.vel_y
        robot_speed= np.sqrt(robot_v_x**2+ robot_v_y**2)
        return robot_speed


    ## restricting the robot's orientation value to be between [-np.pi, +np.pi]
    def wrap(self, orientation):
        if orientation > 2*np.pi:
            orientation -= int(orientation/(2*np.pi))*(2*np.pi)
        if orientation < -2*np.pi:
            orientation += int(abs(orientation)/(2*np.pi))*(2*np.pi)
        if orientation > np.pi: orientation -= 2*np.pi
        elif orientation < -np.pi: orientation += 2*np.pi
        return orientation